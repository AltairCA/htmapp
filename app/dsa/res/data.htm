<?global

	void make_array( t_pb8 &pb, long d, long &i )
	{
		pb[ "name" ] = ++i;
		if ( d && d != i % 5 )
		{	pb[ "children" ].is_list( true );
			//pb[ "colour" ] = "#f9f0ab";
			for( long x = 0; x < d; x++ )
				make_array( pb[ "children" ][ x ], d - 1, i );
		}
		else
			pb[ "size" ] = ++i;		
	}


#include <time.h>
#include "cpp/file_index.h"

	static long g_lThreadId = -1;
	static long g_lCancel = 0;
	static unsigned long g_lLastUpdate = 0;
	
	long add_items( t_pb &pb, CFileIndex::SBlockItem *p, long lDepth = 0 )
	{
		if ( !p || 32 < lDepth )
			return 0;
		
		// If it's the root
		if ( 0 >= lDepth )
		{	pb[ "name" ] = "<root>";
			return add_items( pb[ "children" ], p->child, lDepth + 1 );
		} // end if
		else
			pb.is_list( true );
		
		long i = 0;
		while ( p )
		{
			// Create a new entry
			t_pb &r = pb[ i++ ];
			
			// Set our name
			r[ "name" ] = p->name ? p->name : "<empty>";
	
//			str::Print( "%s\n", p->name ? p->name : "<empty>" );

			// Add children
			if ( p->child )
				add_items( r[ "children" ], p->child, lDepth + 1 );
			else
				r[ "size" ] = p->size;
		
			// Next sibling
			p = p->next;

		} // end while

		return i;
	}
	
	bool index_callback( CFileIndex *pFi, void *p )
	{
//		str::Print( "%s\n", p->name ? p->name : "<empty>" );

		// Update once per second
		const unsigned long t = (const unsigned long)time( 0 );
		if ( t == g_lLastUpdate )
			return g_lCancel;
		g_lLastUpdate = t;

		// Lock the global property bag
		t_pb pb;
		add_items( pb, pFi->getRoot() );
		tq::set( "indexer.out", pb, "." );
		
		return g_lCancel;
	}

	static long index_thread( CThread *t, void *p )
	{
		// Cancel flag
		long *pCancel = (long*)p;

		// Indexing object
		CFileIndex fi( 1024 * 1024 );
		fi.setCallback( index_callback, 0 );
		
		bool bOnce = true;

		// Until we get the kill signal
		while ( t->getStopEvent().Wait( 1000 ) )
		{
			// Do we want to run
//			t_pb job = tq::get( "indexer.job", "." );
//			if ( job[ "run" ].ToLong() )
			if ( bOnce )
			{
				bOnce = false;

				// Clear run flag
				tq::set( "indexer.run", "", "." );

				// Index the file system
//				fi.Index( fi.getRoot(), "/tmp", 32 );
				fi.Index( fi.getRoot(), "/build", 32 );
				
				// Final update
				g_lLastUpdate = 0;
				index_callback( &fi, 0 );

			} // end if

		} // end while

		return 0;
	}

?><?c
/*
	t_pb8 pb;
	long i = 0;
	make_array( pb, 3, i );
	out += parser::EncodeJson< str::t_char8, str::t_string8, t_pb8 >( pb ).c_str();
	return 0;
*/

	// Start the thread
	if ( 0 > g_lThreadId )
		g_lThreadId = tq::start( index_thread, &g_lCancel );

	// Send back output status
	out += parser::EncodeJson< str::t_char8, str::t_string8, t_pb8 >( tq::get( "indexer.out", "." ) ).c_str();

	return 0;
?>
